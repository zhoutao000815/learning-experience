//剑指 Offer 59 - I.滑动窗口的最大值
//给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
//
//示例 :
//
//输入 : nums = [1, 3, -1, -3, 5, 3, 6, 7], 和 k = 3
//输出 : [3, 3, 5, 5, 6, 7]
// 解释 :
//
//	滑动窗口的位置                最大值
//	-------------- - ---- -
//	[1  3 - 1] - 3  5  3  6  7       3
//	1[3 - 1 - 3] 5  3  6  7       3
//	1  3[-1 - 3  5] 3  6  7       5
//	1  3 - 1[-3  5  3] 6  7       5
//	1  3 - 1 - 3[5  3  6] 7       6
//	1  3 - 1 - 3  5[3  6  7]      7
//
//
//	1  3 - 1 - 3[5  3  6] 7       6
//	1  3 - 1 - 3  5[3  6  7]      7
//
//
//
//		 来源：力扣（LeetCode）
//	 链接：https ://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof
//	 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

//单调队列
//1.给定一个滑动窗口，保存数组最大值的下标，并且保证窗口内的所有值都属于同一个窗口，因此我们保证窗口前端的值是最大的即可以每次用O(1)的时间获取这个最大的数字
//
//2.我们不能将值保存在滑动窗口之中，而应该将值对应的下标保存起来，因为值是会**“失效”**的。用i表示当前元素下标，用sub表示窗口首部的下标，当i - sub >= k时，sub就不再当前窗口之中了，因此应该将其出队->这一步保证了窗口内的所有值都处于同一窗口
//
//3.当有新元素来的时候，如果新来的元素大于窗尾的值，则利用循环，将所有小于这个数的值pop出去，因为所有的数字都处于同一窗口，小于当前值的数字已经失效了->这一步保证了，窗口的值是最大的
//
//4.当滑动窗口"装满时"，才能从中获取最大元素进行返回。 当 i + 1 >= k时表示正好装满，在此之后，每添加一个元素，窗口都会往后挪动一位，即每次都要从窗口之中取出一个最大的值

class Solution {
public:
	vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		vector<int> rel;
		deque<int> dq;
		for (int i = 0; i<nums.size(); i++)
		{
			if (!dq.empty() && dq.front() == i - k)
			{
				dq.pop_front();
			}
			while (!dq.empty() && nums[dq.back()]<nums[i])
			{
				dq.pop_back();
			}
			dq.push_back(i);
			if (i + 1 >= k)
			{
				rel.push_back(nums[dq.front()]);
			}
		}
		return rel;
	}
};