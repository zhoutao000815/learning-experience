//746. 使用最小花费爬楼梯
//数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
//
//每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
//
//请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
//
//示例 1：
//
//输入：cost = [10, 15, 20]
//输出：15
//解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
//示例 2：
//
//输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
//输出：6
//解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
//
//
//提示：
//
//cost 的长度范围是[2, 1000]。
//cost[i] 将会是一个整型数据，范围为[0, 999] 。
//
//来源：力扣（LeetCode）
//链接：https ://leetcode-cn.com/problems/min-cost-climbing-stairs
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



//青蛙跳台阶的耗费跳法；
//每登上一个台阶都要+上当前台阶的cost，而当前台阶由前两级中小的那个跳上来，最后一步可以直接跳上去,无需加当前cost。
//所以确定状态方程：dp[i]=min(dp[i-1],dp[i-2])+cost[i]，注意要用dp[i-1]dp[i-2],如果用cost就是贪心算法了，
//dp[i]前后有关联,不能用贪心算法。
//由递推公式很好找出初始化条件，dp[0]dp[1]。
class Solution {
public:
	int minCostClimbingStairs(vector<int>& cost) {
		if (cost.size() == 2)
			return min(cost[0], cost[1]);
		vector<int> dp(cost.size(), 0);
		dp[0] = cost[0];
		dp[1] = cost[1];
		int i = -1;
		for (i = 2; i<dp.size(); i++)
		{
			dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
		}
		return min(dp[i - 1], dp[i - 2]);
	}
};